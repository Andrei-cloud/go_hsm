// Package main implements a CLI to generate WASM plugin wrappers.
package main

import (
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"text/template"
)

const wrapperTemplate = `// DO NOT EDIT THIS FILE.
// Generated by "plugingen"; DO NOT EDIT.

//go:build tinygo.wasm

package main

import (
    "github.com/andrei-cloud/go_hsm/pkg/hsmplugin"
    "{{.LogicImport}}"
)

//export version
func version() uint64 {
    version := []byte("{{.Version}}")
    return uint64(hsmplugin.ToBuffer(version))
}

//export description
func description() uint64 {
    desc := []byte("{{.Description}}")
    return uint64(hsmplugin.ToBuffer(desc))
}

//export author
func author() uint64 {
    author := []byte("{{.Author}}")
    return uint64(hsmplugin.ToBuffer(author))
}

//export Alloc
func Alloc(size uint32) hsmplugin.Buffer {
    return hsmplugin.ToBuffer(make([]byte, size))
}

//export Execute
func Execute(buf hsmplugin.Buffer) uint64 {
	logic.SetDefaultLMKProvider()
    in := hsmplugin.Buffer(buf).ToBytes()

    out, err := logic.Execute{{.Cmd}}(in)
    if err != nil {
        return uint64(hsmplugin.WriteError("{{.Cmd}}", err))
    }

    return uint64(hsmplugin.ToBuffer(out))
}

func main() {}
`

type PluginData struct {
	Cmd         string
	LogicImport string
	Version     string
	Description string
	Author      string
}

func main() {
	// parse flags
	cmd := flag.String("cmd", "", "command name")
	logic := flag.String("logic", "", "logic import path")
	out := flag.String("out", ".", "output directory")
	version := flag.String("version", "1.0.0", "plugin version")
	desc := flag.String("desc", "", "plugin description")
	author := flag.String("author", "HSM Plugin Generator", "plugin author")
	flag.Parse()

	if *cmd == "" || *logic == "" {
		fmt.Fprintln(
			os.Stderr,
			"cmd and logic flags must be provided",
		) //nolint:errcheck // Error output is intentional
		os.Exit(1)
	}

	if *desc == "" {
		*desc = fmt.Sprintf("HSM command %s implementation", *cmd)
	}

	// prepare data
	data := &PluginData{
		Cmd:         *cmd,
		LogicImport: *logic,
		Version:     *version,
		Description: *desc,
		Author:      *author,
	}

	// ensure output directory exists
	if err := os.MkdirAll(*out, 0o755); err != nil {
		fmt.Fprintf(os.Stderr, "failed to create output directory: %v\n", err)
		os.Exit(1)
	}

	// create wrapper file
	wrapperPath := filepath.Join(*out, "main.go")
	if err := generateWrapper(wrapperPath, data); err != nil {
		fmt.Fprintf(os.Stderr, "failed to generate wrapper: %v\n", err)
		os.Exit(1)
	}
}

func generateWrapper(path string, data *PluginData) error {
	f, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("failed to create file: %w", err)
	}
	defer func() {
		_ = f.Close()
	}()

	t := template.Must(template.New("wrapper").Parse(wrapperTemplate))

	return t.Execute(f, data)
}
