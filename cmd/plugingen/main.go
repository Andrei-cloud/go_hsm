// Package main implements a CLI to generate WASM plugin wrappers.
package main

import (
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"text/template"
)

const wrapperTemplate = `// DO NOT EDIT THIS FILE.
// Code generated by "plugingen"; DO NOT EDIT.
package main

import (
    "errors"

    "github.com/andrei-cloud/go_hsm/pkg/cryptoutils"
    "github.com/andrei-cloud/go_hsm/pkg/hsmplugin"
    "{{.LogicImport}}"
)

//go:wasm-module env
//export DecryptUnderLMK
func DecryptUnderLMK(ptr, length uint32) uint64

//go:wasm-module env
//export EncryptUnderLMK
func EncryptUnderLMK(ptr, length uint32) uint64

//go:wasm-module env
//export log_debug
func LogToHost(string)

//export Alloc
func Alloc(size uint32) hsmplugin.Buffer {
  return hsmplugin.ToBuffer(make([]byte, size))
}

//export Execute
func Execute(buf hsmplugin.Buffer) uint64 {
    in := hsmplugin.Buffer(buf).ToBytes()
    LogToHost("{{.Cmd}} command input: " + string(in))

    decryptUnderLMK := func(data []byte) ([]byte, error) {
        if len(data) == 0 {
            return nil, errors.New("encrypt data is empty")
        }
        LogToHost("{{.Cmd}} decrypt request: " + cryptoutils.Raw2Str(data))

        buf := hsmplugin.ToBuffer(data)
        r := DecryptUnderLMK(buf.AddressSize())
        if r == 0 {
            return nil, errors.New("decrypt failed")
        }
        result := hsmplugin.Buffer(r).ToBytes()
        LogToHost("{{.Cmd}} decrypt result: " + cryptoutils.Raw2Str(result))

        return result, nil
    }

    encryptUnderLMK := func(data []byte) ([]byte, error) {
        if len(data) == 0 {
            return nil, errors.New("encrypt data is empty")
        }
        LogToHost("{{.Cmd}} encrypt request: " + string(data))

        buf := hsmplugin.ToBuffer(data)
        r := EncryptUnderLMK(buf.AddressSize())
        if r == 0 {
            return nil, errors.New("encrypt failed")
        }
        result := hsmplugin.Buffer(r).ToBytes()
        LogToHost("{{.Cmd}} encrypt result: " + cryptoutils.Raw2Str(result))

        return result, nil
    }

    logToHost := func(data string) {
        LogToHost(data)
    }

    out, err := logic.Execute{{.Cmd}}(in, decryptUnderLMK, encryptUnderLMK, logToHost)
    if err != nil {
        LogToHost("{{.Cmd}} execution failed: " + err.Error())
        return uint64(hsmplugin.WriteError("{{.Cmd}} "))
    }

    LogToHost("{{.Cmd}} command output: " + string(out))

    return uint64(hsmplugin.ToBuffer(out))
}

func main() {}
`

func main() {
	// parse flags
	cmd := flag.String("cmd", "", "command name")
	logic := flag.String("logic", "", "logic import path")
	out := flag.String("out", ".", "output directory")
	flag.Parse()

	if *cmd == "" || *logic == "" {
		fmt.Fprintln(os.Stderr, "cmd and logic flags must be provided.")
		os.Exit(1)
	}

	// prepare data
	data := struct {
		Cmd         string
		LogicImport string
	}{
		Cmd:         *cmd,
		LogicImport: *logic,
	}

	// create output file
	path := filepath.Join(*out, "main.go")
	f, err := os.Create(path)
	if err != nil {
		fmt.Fprintf(os.Stderr, "failed to create file: %v", err)
		os.Exit(1)
	}
	// render template
	t := template.Must(template.New("wrapper").Parse(wrapperTemplate))
	err = t.Execute(f, data)
	if cerr := f.Close(); cerr != nil {
		fmt.Fprintf(os.Stderr, "failed to close file: %v", cerr)
	}
	if err != nil {
		fmt.Fprintf(os.Stderr, "failed to execute template: %v", err)
		os.Exit(1)
	}
}
