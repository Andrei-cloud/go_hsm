// Package main implements a CLI to generate WASM plugin wrappers.
package main

import (
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"text/template"
)

const wrapperTemplate = `// DO NOT EDIT THIS FILE.
// Code generated by "plugingen"; DO NOT EDIT.
package main

import (
	"github.com/andrei-cloud/go_hsm/pkg/hsmplugin"
	"{{.LogicImport}}"
)

//export Alloc
func Alloc(size uint32) uint32 {

	return hsmplugin.Alloc(size)
}

//export Free
func Free(ptr uint32) {

	hsmplugin.Free(ptr)
}

//export Execute
func Execute(ptr, length uint32) uint64 {

	hsmplugin.ResetAllocator()

	in := hsmplugin.ReadBytes(ptr, length)
	out, err := logic.Execute{{.Cmd}}(in)
	if err != nil {

		return hsmplugin.WriteError("{{.Cmd}}")
	}

	p := hsmplugin.Alloc(uint32(len(out)))
	hsmplugin.WriteBytes(p, out)

	return hsmplugin.PackResult(p, uint32(len(out)))
}

func main() {}
`

func main() {
	// parse flags
	cmd := flag.String("cmd", "", "command name")
	logic := flag.String("logic", "", "logic import path")
	out := flag.String("out", ".", "output directory")
	flag.Parse()

	if *cmd == "" || *logic == "" {
		fmt.Fprintln(os.Stderr, "cmd and logic flags must be provided.")
		os.Exit(1)
	}

	// prepare data
	data := struct {
		Cmd         string
		LogicImport string
	}{
		Cmd:         *cmd,
		LogicImport: *logic,
	}

	// create output file
	path := filepath.Join(*out, "main.go")
	f, err := os.Create(path)
	if err != nil {
		fmt.Fprintf(os.Stderr, "failed to create file: %v", err)
		os.Exit(1)
	}
	// render template
	t := template.Must(template.New("wrapper").Parse(wrapperTemplate))
	err = t.Execute(f, data)
	if cerr := f.Close(); cerr != nil {
		fmt.Fprintf(os.Stderr, "failed to close file: %v", cerr)
	}
	if err != nil {
		fmt.Fprintf(os.Stderr, "failed to execute template: %v", err)
		os.Exit(1)
	}
}
