// Package main implements a CLI to generate WASM plugin wrappers.
package main

import (
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"text/template"
)

const wrapperTemplate = `// DO NOT EDIT THIS FILE.
// Code generated by "plugingen"; DO NOT EDIT.
package main

import (
    "github.com/andrei-cloud/go_hsm/pkg/hsmplugin"
    "{{.LogicImport}}"
)

//go:wasm-module env
//export DecryptUnderLMK
func DecryptUnderLMK(ptr, length uint32) uint64

//go:wasm-module env
//export EncryptUnderLMK
func EncryptUnderLMK(ptr, length uint32) uint64

//export Alloc
func Alloc(size uint32) uint32 { return hsmplugin.Alloc(size) }

//export Free
func Free(ptr uint32) { hsmplugin.Free(ptr) }

//export ResetAllocator
func ResetAllocator() { hsmplugin.ResetAllocator() }

//export Execute
func Execute(ptr, length uint32) uint64 {
    hsmplugin.ResetAllocator()
    // Create a new slice to copy input to prevent null termination issues
    data := make([]byte, length)
    copy(data, hsmplugin.ReadBytes(ptr, length))

    decryptUnderLMK := func(data []byte) ([]byte, error) {
        p := Alloc(uint32(len(data)))
        hsmplugin.WriteBytes(p, data)
        r := DecryptUnderLMK(p, uint32(len(data)))
        if r == 0 {
            return nil, nil
        }

        rPtr := uint32(r >> 32)
        rLen := uint32(r)

        return hsmplugin.ReadBytes(rPtr, rLen), nil
    }

    encryptUnderLMK := func(data []byte) ([]byte, error) {
        p := Alloc(uint32(len(data)))
        hsmplugin.WriteBytes(p, data)
        r := EncryptUnderLMK(p, uint32(len(data)))
        if r == 0 {
            return nil, nil
        }

        rPtr := uint32(r >> 32)
        rLen := uint32(r)

        return hsmplugin.ReadBytes(rPtr, rLen), nil
    }

    out, err := logic.Execute{{.Cmd}}(data, decryptUnderLMK, encryptUnderLMK)
    if err != nil {
        return hsmplugin.WriteError("{{.Cmd}}")
    }

    // reset allocator before writing plugin output so pointer starts fresh.
    hsmplugin.ResetAllocator()

    p := Alloc(uint32(len(out)))
    hsmplugin.WriteBytes(p, out)

    return hsmplugin.PackResult(p, uint32(len(out)))
}

func main() {}
`

func main() {
	// parse flags
	cmd := flag.String("cmd", "", "command name")
	logic := flag.String("logic", "", "logic import path")
	out := flag.String("out", ".", "output directory")
	flag.Parse()

	if *cmd == "" || *logic == "" {
		fmt.Fprintln(os.Stderr, "cmd and logic flags must be provided.")
		os.Exit(1)
	}

	// prepare data
	data := struct {
		Cmd         string
		LogicImport string
	}{
		Cmd:         *cmd,
		LogicImport: *logic,
	}

	// create output file
	path := filepath.Join(*out, "main.go")
	f, err := os.Create(path)
	if err != nil {
		fmt.Fprintf(os.Stderr, "failed to create file: %v", err)
		os.Exit(1)
	}
	// render template
	t := template.Must(template.New("wrapper").Parse(wrapperTemplate))
	err = t.Execute(f, data)
	if cerr := f.Close(); cerr != nil {
		fmt.Fprintf(os.Stderr, "failed to close file: %v", cerr)
	}
	if err != nil {
		fmt.Fprintf(os.Stderr, "failed to execute template: %v", err)
		os.Exit(1)
	}
}
