// Package main implements a CLI to generate WASM plugin wrappers.
package main

import (
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"text/template"
)

const wrapperTemplate = `// DO NOT EDIT THIS FILE.
// Code generated by "plugingen"; DO NOT EDIT.
package main

import (
    "fmt"
    "github.com/andrei-cloud/go_hsm/pkg/hsmplugin"
    "{{.LogicImport}}"
)

//go:wasm-module env
//export DecryptUnderLMK
func DecryptUnderLMK(ptr, length uint32) uint64

//go:wasm-module env
//export EncryptUnderLMK
func EncryptUnderLMK(ptr, length uint32) uint64

//export Alloc
func Alloc(size uint32) hsmplugin.Buffer {
  return hsmplugin.ToBuffer(make([]byte, size))
}

//export Execute
func Execute(buf hsmplugin.Buffer) uint64 {
    in := hsmplugin.Buffer(buf).ToBytes()
    hsmplugin.LogToHost(fmt.Sprintf("{{.Cmd}}  command input: %x", in))

    decryptUnderLMK := func(data []byte) ([]byte, error) {
        if len(data) == 0 {
            return nil, fmt.Errorf("encrypt data is empty")
        }
        hsmplugin.LogToHost(fmt.Sprintf("{{.Cmd}}  decrypt request: %x", data))

        buf := hsmplugin.ToBuffer(data)

        r := DecryptUnderLMK(buf.AddressSize())
        if r == 0 {
            hsmplugin.LogToHost("{{.Cmd}}  decrypt failed")
            return nil, fmt.Errorf("decrypt failed")
        }

        result := hsmplugin.Buffer(r).ToBytes()
        hsmplugin.LogToHost(fmt.Sprintf("{{.Cmd}}  decrypt result: %x", result))

        return result, nil
    }

    encryptUnderLMK := func(data []byte) ([]byte, error) {
        if len(data) == 0 {
            return nil, fmt.Errorf("encrypt data is empty")
        }
        hsmplugin.LogToHost(fmt.Sprintf("{{.Cmd}}  encrypt request: %x", data))


        buf := hsmplugin.ToBuffer(data)
        
        r := EncryptUnderLMK(buf.AddressSize())
        if r == 0 {
            hsmplugin.LogToHost("{{.Cmd}}  encrypt failed")
            return nil, fmt.Errorf("encrypt failed")
        }

        result := hsmplugin.Buffer(r).ToBytes()
    
        hsmplugin.LogToHost(fmt.Sprintf("{{.Cmd}}  encrypt result: %x", result))

        return result, nil
    }

    out, err := logic.Execute{{.Cmd}}(in, decryptUnderLMK, encryptUnderLMK)
    if err != nil {
        hsmplugin.LogToHost(fmt.Sprintf("{{.Cmd}}  execution failed: %v", err))
        return uint64(hsmplugin.WriteError("{{.Cmd}} "))
    }

    hsmplugin.LogToHost(fmt.Sprintf("{{.Cmd}}  command output: %x", out))

    return uint64(hsmplugin.ToBuffer(out))
}

func main() {}
`

func main() {
	// parse flags
	cmd := flag.String("cmd", "", "command name")
	logic := flag.String("logic", "", "logic import path")
	out := flag.String("out", ".", "output directory")
	flag.Parse()

	if *cmd == "" || *logic == "" {
		fmt.Fprintln(os.Stderr, "cmd and logic flags must be provided.")
		os.Exit(1)
	}

	// prepare data
	data := struct {
		Cmd         string
		LogicImport string
	}{
		Cmd:         *cmd,
		LogicImport: *logic,
	}

	// create output file
	path := filepath.Join(*out, "main.go")
	f, err := os.Create(path)
	if err != nil {
		fmt.Fprintf(os.Stderr, "failed to create file: %v", err)
		os.Exit(1)
	}
	// render template
	t := template.Must(template.New("wrapper").Parse(wrapperTemplate))
	err = t.Execute(f, data)
	if cerr := f.Close(); cerr != nil {
		fmt.Fprintf(os.Stderr, "failed to close file: %v", cerr)
	}
	if err != nil {
		fmt.Fprintf(os.Stderr, "failed to execute template: %v", err)
		os.Exit(1)
	}
}
